- Для jenkins нужно настроить web hook в github
Передать туда адрес сервера, где работает jenkins и вставить логин github и токен github(истечет в мае)

- Для открытия порта на локальном компьютере я использовал(так как сервер не соберет docker-compose,
хотя и не надо было):
ssh -p 443 -R0:127.0.0.1:8090 qr@a.pinggy.io

- в jenkins нужно добавить ssh ключ (как username-password) в credentials, чтобы работать с github и multipipeline увидил ключ.

- web hook работает при открытии pull request в ветку develop, при push в ветку develop, но это должно
быть запрещено, только добавление коммитов в открытый pull request.

- там высвечивается маркер, что jenkins запустил сборку, потом высвечивается результат, если тимлид видит, что все запустилось, то сливает pull request в ветку, другие это делать не могут.

- оставлю историю сообщений с deepseek по настройке jenkins, много мусора.

- чтобы jenkins подтягивал все submodules нужно настроить это в multipipeline.

- по поводу jenkinsfile, тестирования отдельных микросервисов и всего приложения.

## работа jenkins и docker-compose:

### Для одного микросервиса:
в каждом репозитории(для каждого микросервиса) свой jenkinsfile, свой docker-compose (только с микросервисом и бд). При открытии pull request в ветку develop микросервиса запускается jenkins, он поднимает docker-compose этого сервиса, запускает unit и интеграционные тесты(api), короче только те тесты, которые либо тестируют апи, но вызов других микросервисов mockнут, либо используют напрямую бд, либо только внутреннюю логику микросервиса.
Далее приходит лид, если все успешно прошло, применяет pull request, изменения вливаются в develop. Ветка main получается не нужна в этих репозиториях. Либо когда уже на прод выкатили изменения (после тестирования в полном окружении), можно слить в main, чтобы в случае чего создавать fix ветки.

### Для всего приложения:
Есть общий репозиторий infra, там ссылки на остальные репозитории, общий jenkinsfile, docker-compose со всеми зависимостями.
Лид создает новую ветку в infra репозитории, стягивает все изменения из других репозиториев(develop веток, уже оттестированных unit и интеграционными тестами), сам открывает pull request в develop, запускается docker-compose со всеми микросервисами и зависимостями. Здесь должны запускаться реальные api тесты, проверяют взаимодействие между микросервисами, тесты взаимодействия с другими зависимостями(redis, kafka), end-to-end тесты, которые проверяют конкретные пользовательские сценарии(frontend -> backend -> db).

Я писал unit, интеграционные мокнутые, апи-тесты, end-to-end - писали qa.
e2e не будет в jenkins, с ними тестировщики работают, после всех остальных.
